datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id          String   @id @default(cuid())
  clerkUserId String   @unique
  email       String
  createdAt   DateTime @default(now())

  bankConnections BankConnection[]
  holdings        Holding[]
}

model BankConnection {
  id              String @id @default(cuid())
  userId          String
  provider        String // plaid | truelayer | tink | yapily | mock
  providerItemId  String // item_id / consent_id
  consentId       String? // yapily consent_id
  institutionName String
  institutionId   String

  accessToken  String // encrypted later
  refreshToken String? // encrypted later

  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  accounts   Account[]
  syncCursor SyncCursor?

  @@unique([provider, providerItemId])
  @@index([userId])
}

model Account {
  id               String @id @default(cuid())
  bankConnectionId String

  providerAccountId String
  name              String
  type              String // checking | savings | credit
  currency          String
  balance           Decimal  @db.Decimal(18, 2)
  availableBalance  Decimal? @db.Decimal(18, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bankConnection BankConnection @relation(fields: [bankConnectionId], references: [id], onDelete: Cascade)
  transactions   Transaction[]

  @@unique([bankConnectionId, providerAccountId])
  @@index([bankConnectionId])
}

model Transaction {
  id        String @id @default(cuid())
  accountId String

  providerTransactionId String
  amount                Decimal @db.Decimal(18, 2)
  currency              String
  description           String
  category              String?
  merchant              String?

  date    DateTime
  pending Boolean  @default(false)

  createdAt DateTime @default(now())

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([accountId, providerTransactionId])
  @@index([date])
  @@index([accountId, date])
}

model SyncCursor {
  id               String   @id @default(cuid())
  bankConnectionId String   @unique
  cursor           String
  updatedAt        DateTime @updatedAt

  bankConnection BankConnection @relation(fields: [bankConnectionId], references: [id], onDelete: Cascade)
}

model Institution {
  id               String    @id
  name             String
  fullName         String
  countries        Country[]
  logoUrl          String
  iconUrl          String
  primaryColor     String
  credentialsType  String
  media            Json
  features         Json
  status           String
  statusUpdateAt   DateTime?
  monitoring         Json
}

model Country {
  countryCode2 String @id
  displayName  String

  institutions Institution[]
}

model Investment {
  id        String @id @default(cuid())
  symbol    String @unique
  name      String
  currency  String
  lastPrice Decimal? @db.Decimal(18, 2)
  updatedAt DateTime @updatedAt

  holdings Holding[]
}

model Holding {
  id        String @id @default(cuid())
  userId    String
  investmentId String
  quantity  Decimal  @db.Decimal(18, 4)
  price     Decimal  @db.Decimal(18, 2)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  investment Investment @relation(fields: [investmentId], references: [id])

  @@unique([userId, investmentId])
}
